name: Upstream Release Monitor
# æ¯æ—¥è‡ªåŠ¨æ£€æµ‹ä¸Šæ¸¸ openclaw/openclaw æ–° Release
# æ£€æµ‹ â†’ æå–åˆ†ç±» â†’ åˆ›å»º Issue â†’ è‡ªåŠ¨ cherry-pick â†’ åˆ›å»º PR

on:
  schedule:
    # æ¯å¤© UTC 08:00ï¼ˆåŒ—äº¬æ—¶é—´ 16:00ï¼‰
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      baseline_override:
        description: 'è¦†ç›–åŸºå‡†ç‰ˆæœ¬ (ç•™ç©ºåˆ™è¯» last-upstream-tag)'
        type: string
        default: ''
      dry_run:
        description: 'æµ‹è¯•æ¨¡å¼: åªåˆ›å»º Issueï¼Œä¸æäº¤/ä¸è§¦å‘ cherry-pick'
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  UPSTREAM_REPO: openclaw/openclaw
  LAST_TAG_FILE: .github/last-upstream-tag

jobs:
  # ================================================================
  # Job 1: æ£€æµ‹ä¸Šæ¸¸æ–° Release
  # ================================================================
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      has_new: ${{ steps.check.outputs.has_new }}
      latest_tag: ${{ steps.check.outputs.latest_tag }}
      prev_tag: ${{ steps.check.outputs.prev_tag }}
      release_tags: ${{ steps.check.outputs.release_tags }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect new upstream releases
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # è¯»å–åŸºå‡†ç‰ˆæœ¬ï¼ˆæ”¯æŒæ‰‹åŠ¨è¦†ç›–ï¼‰
          OVERRIDE="${{ inputs.baseline_override }}"
          if [ -n "$OVERRIDE" ]; then
            PREV_TAG="$OVERRIDE"
            echo "Using manual override baseline: $PREV_TAG"
          elif [ -f "$LAST_TAG_FILE" ]; then
            PREV_TAG=$(cat "$LAST_TAG_FILE" | tr -d '[:space:]')
          else
            PREV_TAG="v2026.1.29"
          fi
          echo "prev_tag=$PREV_TAG" >> "$GITHUB_OUTPUT"
          echo "Baseline: $PREV_TAG"

          # è·å–ä¸Šæ¸¸æ­£å¼ Releaseï¼ˆæ’é™¤è‰ç¨¿å’Œé¢„å‘å¸ƒï¼‰
          RELEASES=$(gh api "repos/$UPSTREAM_REPO/releases" --paginate \
            --jq "[.[] | select(.draft == false and .prerelease == false) | {tag: .tag_name}]")

          # æ•°å€¼ç‰ˆæœ¬æ¯”è¾ƒè¿‡æ»¤
          NEW=$(echo "$RELEASES" | jq -c --arg last "$PREV_TAG" '
            def ver: ltrimstr("v") | split("-")[0] | split(".") | map(tonumber);
            [.[] | select(
              (.tag | ver) as $t | ($last | ver) as $l |
              ($t[0] > $l[0]) or
              ($t[0] == $l[0] and $t[1] > $l[1]) or
              ($t[0] == $l[0] and $t[1] == $l[1] and ($t[2] // 0) > ($l[2] // 0))
            )]')

          COUNT=$(echo "$NEW" | jq 'length')
          echo "Found $COUNT new release(s)"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_new=true" >> "$GITHUB_OUTPUT"
            LATEST=$(echo "$NEW" | jq -r '
              def ver: ltrimstr("v") | split("-")[0] | split(".") | map(tonumber);
              [.[] | .tag] | sort_by(. | ver) | last')
            echo "latest_tag=$LATEST" >> "$GITHUB_OUTPUT"
            TAGS=$(echo "$NEW" | jq -r '[.[].tag] | join(", ")')
            echo "release_tags=$TAGS" >> "$GITHUB_OUTPUT"
          else
            echo "has_new=false" >> "$GITHUB_OUTPUT"
          fi

  # ================================================================
  # Job 2: æå– commitã€åˆ›å»º Issueã€æ›´æ–°åŸºå‡†
  # ================================================================
  extract-and-notify:
    needs: check-upstream
    if: needs.check-upstream.outputs.has_new == 'true'
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.issue.outputs.number }}
      merge_count: ${{ steps.stats.outputs.merge_count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup upstream remote
        run: |
          git remote add upstream "https://github.com/$UPSTREAM_REPO.git" 2>/dev/null || true
          git fetch upstream --tags --force
          git fetch upstream main

      - name: Extract and categorize commits
        run: |
          chmod +x scripts/upstream-extract-commits.sh
          ./scripts/upstream-extract-commits.sh \
            "${{ needs.check-upstream.outputs.prev_tag }}" \
            "${{ needs.check-upstream.outputs.latest_tag }}" \
            > /tmp/commits.json 2>/tmp/extract.log || {
            echo "::error::Extract script failed"
            cat /tmp/extract.log
            exit 1
          }
          cat /tmp/extract.log

      - name: Calculate statistics
        id: stats
        run: |
          f() { jq "$1" /tmp/commits.json; }
          echo "total=$(f 'length')" >> "$GITHUB_OUTPUT"
          echo "merge_count=$(f '[.[] | select(.action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "p0=$(f '[.[] | select(.priority == "P0" and .action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "p1=$(f '[.[] | select(.priority == "P1" and .action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "review=$(f '[.[] | select(.action == "REVIEW")] | length')" >> "$GITHUB_OUTPUT"
          echo "skip=$(f '[.[] | select(.action == "SKIP")] | length')" >> "$GITHUB_OUTPUT"
          echo "optional=$(f '[.[] | select(.action == "OPTIONAL")] | length')" >> "$GITHUB_OUTPUT"

      - name: Create issue with embedded checklist
        id: issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREV="${{ needs.check-upstream.outputs.prev_tag }}"
          LATEST="${{ needs.check-upstream.outputs.latest_tag }}"
          TAGS="${{ needs.check-upstream.outputs.release_tags }}"

          # å»é‡æ£€æŸ¥
          EXISTING=$(gh issue list --label "upstream" --state open \
            --search "$LATEST in:title" --json number --jq '.[0].number // empty')
          if [ -n "$EXISTING" ]; then
            echo "number=$EXISTING" >> "$GITHUB_OUTPUT"
            echo "Issue #$EXISTING already exists, skipping"
            exit 0
          fi

          P0="${{ steps.stats.outputs.p0 }}"
          P1="${{ steps.stats.outputs.p1 }}"
          MERGE="${{ steps.stats.outputs.merge_count }}"
          REVIEW="${{ steps.stats.outputs.review }}"
          SKIP="${{ steps.stats.outputs.skip }}"
          OPTIONAL="${{ steps.stats.outputs.optional }}"
          TOTAL="${{ steps.stats.outputs.total }}"

          # æ„å»º Issue å†…å®¹
          {
            echo "## ä¸Šæ¸¸æ–° Release: $TAGS"
            echo ""
            echo "**èŒƒå›´**: \`$PREV\` â†’ \`$LATEST\` | å…± **$TOTAL** ä¸ª commit"
            echo ""
            echo "### ğŸ“Š åˆ†ç±»æ‘˜è¦"
            echo ""
            echo "| ç±»åˆ« | æ•°é‡ | å¤„ç†æ–¹å¼ |"
            echo "|------|------|----------|"
            echo "| ğŸ”´ P0 å®‰å…¨ä¿®å¤ | **$P0** | è‡ªåŠ¨ cherry-pick |"
            echo "| ğŸŸ  P1 å…³é”®ä¿®å¤ | **$P1** | è‡ªåŠ¨ cherry-pick |"
            echo "| ğŸ‘ éœ€äººå·¥å®¡æŸ¥ | **$REVIEW** | æ‰‹åŠ¨å¤„ç† |"
            echo "| ğŸ”µ å¯é€‰ | **$OPTIONAL** | æŒ‰éœ€ |"
            echo "| âšª å·²è·³è¿‡ | **$SKIP** | ä¸ä½¿ç”¨çš„æ¸ é“/CI/docs |"
            echo ""
            echo "---"
            echo ""
            echo "### âœ… è‡ªåŠ¨åˆå¹¶æ¸…å• (P0+P1)"
            echo ""
            if [ "$MERGE" -gt 0 ]; then
              echo "| çŠ¶æ€ | ä¼˜å…ˆçº§ | Commit | æè¿° | ç±»åˆ« | é£é™© |"
              echo "|------|--------|--------|------|------|------|"
              jq -r '.[] | select(.action == "MERGE") |
                "| â³ | \(.priority) | `\(.sha[:10])` | \(.message | gsub("[|]"; "/")) | \(.category) | \(.conflict_risk) |"' \
                /tmp/commits.json
            else
              echo "_æ— éœ€åˆå¹¶çš„ commit_"
            fi
            echo ""
            echo "> ğŸ¤– è‡ªåŠ¨ cherry-pick PR åˆ›å»ºåå°†åœ¨ä¸‹æ–¹è¯„è®ºæ›´æ–°ç»“æœ"
            echo ""
            if [ "$REVIEW" -gt 0 ]; then
              echo "### ğŸ‘ éœ€äººå·¥å®¡æŸ¥"
              echo ""
              echo "| Commit | æè¿° | ç±»åˆ« | å¤‡æ³¨ |"
              echo "|--------|------|------|------|"
              jq -r '.[] | select(.action == "REVIEW") |
                "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/")) | \(.category) | éœ€å¯¹æ¯”æœ¬åœ°å®ç° |"' \
                /tmp/commits.json
              echo ""
            fi
            if [ "$OPTIONAL" -gt 0 ]; then
              echo "<details>"
              echo "<summary>ğŸ”µ å¯é€‰åˆå¹¶ ($OPTIONAL ä¸ª)</summary>"
              echo ""
              echo "| Commit | æè¿° | ç±»åˆ« |"
              echo "|--------|------|------|"
              jq -r '.[] | select(.action == "OPTIONAL") |
                "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/") | .[0:80]) | \(.category) |"' \
                /tmp/commits.json | head -50
              echo ""
              echo "</details>"
              echo ""
            fi
            echo "<details>"
            echo "<summary>âšª å·²è·³è¿‡ ($SKIP ä¸ª)</summary>"
            echo ""
            echo "| Commit | æè¿° | ç±»åˆ« |"
            echo "|--------|------|------|"
            jq -r '.[] | select(.action == "SKIP") |
              "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/") | .[0:60]) | \(.category) |"' \
              /tmp/commits.json | head -50
            SKIP_INT=$(jq '[.[] | select(.action == "SKIP")] | length' /tmp/commits.json)
            if [ "$SKIP_INT" -gt 50 ]; then
              echo ""
              echo "_... åŠå…¶ä»– $((SKIP_INT - 50)) ä¸ª commit_"
            fi
            echo ""
            echo "</details>"
            echo ""
            echo "---"
            echo ""
            echo "### ğŸ”§ æ‰‹åŠ¨è¡¥å……æ“ä½œ"
            echo ""
            echo '```bash'
            echo "# å®¡æŸ¥é¡¹"
            echo "./scripts/upstream-cherry-pick.sh --priority P2 --dry-run"
            echo "# å¯é€‰é¡¹"
            echo "./scripts/upstream-cherry-pick.sh --priority P0,P1,P2,P3 --dry-run"
            echo '```'
            echo ""
            echo "æˆ–: **Actions â†’ Upstream Cherry-Pick** â†’ é€‰æ‹©ä¼˜å…ˆçº§"
            echo ""
            echo "### ğŸ›¡ Cherry-pick ä¿æŠ¤æœºåˆ¶"
            echo "è‡ªåŠ¨æ¢å¤æœ¬åœ°æ–‡ä»¶: \`docs/\` \`extensions/feishu/\` \`package.json\` \`.github/workflows/\` \`CHANGELOG.md\` \`README.md\`"
          } > /tmp/issue-body.md

          gh label create upstream --description "ä¸Šæ¸¸å˜æ›´è¿½è¸ª" --color "0075ca" 2>/dev/null || true

          ISSUE_URL=$(gh issue create \
            --title "ä¸Šæ¸¸æ›´æ–°: $TAGS â€” ${P0} P0 + ${P1} P1 å¾…åˆå¹¶" \
            --body-file /tmp/issue-body.md \
            --label "upstream")

          NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          echo "number=$NUMBER" >> "$GITHUB_OUTPUT"
          echo "Created issue #$NUMBER"

      - name: Update baseline tag
        if: ${{ !inputs.dry_run }}
        run: |
          git config user.name "upstream-monitor[bot]"
          git config user.email "bot@openclaw-cn.dev"

          LATEST="${{ needs.check-upstream.outputs.latest_tag }}"
          PREV="${{ needs.check-upstream.outputs.prev_tag }}"

          echo "$LATEST" > "$LAST_TAG_FILE"

          COMMIT_MAP_DIR=".github/upstream-commits"
          mkdir -p "$COMMIT_MAP_DIR"
          cp /tmp/commits.json "$COMMIT_MAP_DIR/${PREV}..${LATEST}.json"

          git add "$LAST_TAG_FILE" "$COMMIT_MAP_DIR/"
          if ! git diff --cached --quiet; then
            git commit -m "chore: track upstream $LATEST"
            git push
          fi

  # ================================================================
  # Job 3: è‡ªåŠ¨ cherry-pick P0+P1 å¹¶åˆ›å»º PR
  # ================================================================
  auto-cherry-pick:
    needs: [check-upstream, extract-and-notify]
    if: ${{ !inputs.dry_run && fromJSON(needs.extract-and-notify.outputs.merge_count) > 0 }}
    uses: ./.github/workflows/upstream-cherry-pick.yml
    with:
      from_tag: ${{ needs.check-upstream.outputs.prev_tag }}
      to_tag: ${{ needs.check-upstream.outputs.latest_tag }}
      priority: 'P0,P1'
      dry_run: false
      skip_build: true
      issue_number: ${{ needs.extract-and-notify.outputs.issue_number }}
    secrets: inherit
