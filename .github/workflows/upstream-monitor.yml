name: Upstream Release Monitor
# æ¯æ—¥è‡ªåŠ¨æ£€æµ‹ä¸Šæ¸¸ openclaw/openclaw æ–° Release
# æ£€æµ‹ â†’ AI åˆ†æ â†’ åˆ›å»º Issue â†’ è‡ªåŠ¨ cherry-pick â†’ åˆ›å»º PR

on:
  schedule:
    # æ¯å¤© UTC 08:00ï¼ˆåŒ—äº¬æ—¶é—´ 16:00ï¼‰
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      baseline_override:
        description: 'è¦†ç›–åŸºå‡†ç‰ˆæœ¬ (ç•™ç©ºåˆ™è¯» last-upstream-tag)'
        type: string
        default: ''
      dry_run:
        description: 'æµ‹è¯•æ¨¡å¼: åªåˆ›å»º Issueï¼Œä¸æäº¤/ä¸è§¦å‘ cherry-pick'
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  UPSTREAM_REPO: openclaw/openclaw
  LAST_TAG_FILE: .github/last-upstream-tag

jobs:
  # ================================================================
  # Job 1: æ£€æµ‹ä¸Šæ¸¸æ–° Release
  # ================================================================
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      has_new: ${{ steps.check.outputs.has_new }}
      latest_tag: ${{ steps.check.outputs.latest_tag }}
      prev_tag: ${{ steps.check.outputs.prev_tag }}
      release_tags: ${{ steps.check.outputs.release_tags }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect new upstream releases
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # è¯»å–åŸºå‡†ç‰ˆæœ¬ï¼ˆæ”¯æŒæ‰‹åŠ¨è¦†ç›–ï¼‰
          OVERRIDE="${{ inputs.baseline_override }}"
          if [ -n "$OVERRIDE" ]; then
            PREV_TAG="$OVERRIDE"
            echo "Using manual override baseline: $PREV_TAG"
          elif [ -f "$LAST_TAG_FILE" ]; then
            PREV_TAG=$(cat "$LAST_TAG_FILE" | tr -d '[:space:]')
          else
            PREV_TAG="v2026.1.29"
          fi
          echo "prev_tag=$PREV_TAG" >> "$GITHUB_OUTPUT"
          echo "Baseline: $PREV_TAG"

          # è·å–ä¸Šæ¸¸æ­£å¼ Releaseï¼ˆæ’é™¤è‰ç¨¿å’Œé¢„å‘å¸ƒï¼‰
          RELEASES=$(gh api "repos/$UPSTREAM_REPO/releases" --paginate \
            --jq "[.[] | select(.draft == false and .prerelease == false) | {tag: .tag_name}]")

          # æ•°å€¼ç‰ˆæœ¬æ¯”è¾ƒè¿‡æ»¤
          NEW=$(echo "$RELEASES" | jq -c --arg last "$PREV_TAG" '
            def ver: ltrimstr("v") | split("-")[0] | split(".") | map(tonumber);
            [.[] | select(
              (.tag | ver) as $t | ($last | ver) as $l |
              ($t[0] > $l[0]) or
              ($t[0] == $l[0] and $t[1] > $l[1]) or
              ($t[0] == $l[0] and $t[1] == $l[1] and ($t[2] // 0) > ($l[2] // 0))
            )]')

          COUNT=$(echo "$NEW" | jq 'length')
          echo "Found $COUNT new release(s)"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_new=true" >> "$GITHUB_OUTPUT"
            LATEST=$(echo "$NEW" | jq -r '
              def ver: ltrimstr("v") | split("-")[0] | split(".") | map(tonumber);
              [.[] | .tag] | sort_by(. | ver) | last')
            echo "latest_tag=$LATEST" >> "$GITHUB_OUTPUT"
            TAGS=$(echo "$NEW" | jq -r '[.[].tag] | join(", ")')
            echo "release_tags=$TAGS" >> "$GITHUB_OUTPUT"
          else
            echo "has_new=false" >> "$GITHUB_OUTPUT"
          fi

  # ================================================================
  # Job 2: æå– commit â†’ AI åˆ†æ â†’ åˆ›å»º Issue â†’ ä¸Šä¼  artifact
  # ================================================================
  extract-and-notify:
    needs: check-upstream
    if: needs.check-upstream.outputs.has_new == 'true'
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.issue.outputs.number }}
      merge_count: ${{ steps.stats.outputs.merge_count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup upstream remote
        run: |
          git remote add upstream "https://github.com/$UPSTREAM_REPO.git" 2>/dev/null || true
          git fetch upstream --tags --force
          git fetch upstream main

      - name: Extract commits (mechanical)
        run: |
          chmod +x scripts/upstream-extract-commits.sh
          ./scripts/upstream-extract-commits.sh \
            "${{ needs.check-upstream.outputs.prev_tag }}" \
            "${{ needs.check-upstream.outputs.latest_tag }}" \
            > /tmp/commits-raw.json 2>/tmp/extract.log || {
            echo "::error::Extract script failed"
            cat /tmp/extract.log
            exit 1
          }
          cat /tmp/extract.log
          # åˆå§‹æ–‡ä»¶ç”±è„šæœ¬è§„åˆ™åˆ†ç±»ï¼Œåç»­ AI ä¼šè¦†ç›–
          cp /tmp/commits-raw.json /tmp/commits.json

      - name: AI analysis and refinement
        id: ai
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
          AI_PROVIDER: ${{ secrets.AI_PROVIDER || vars.AI_PROVIDER || 'deepseek' }}
          AI_BASE_URL: ${{ secrets.AI_BASE_URL || vars.AI_BASE_URL || '' }}
          AI_MODEL: ${{ secrets.AI_MODEL || vars.AI_MODEL || '' }}
        run: |
          if [ -z "$AI_API_KEY" ]; then
            echo "â„¹ï¸ AI_API_KEY æœªé…ç½®ï¼Œä½¿ç”¨è„šæœ¬è§„åˆ™åˆ†ç±»"
            echo "ai_used=false" >> "$GITHUB_OUTPUT"
            echo "ai_status=not_configured" >> "$GITHUB_OUTPUT"
            echo "ai_overrides=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # ---- é€‰æ‹© AI ä¾›åº”å•† ----
          case "$AI_PROVIDER" in
            deepseek)    BASE_URL="${AI_BASE_URL:-https://api.deepseek.com/v1}"; MODEL="${AI_MODEL:-deepseek-chat}" ;;
            siliconflow) BASE_URL="${AI_BASE_URL:-https://api.siliconflow.cn/v1}"; MODEL="${AI_MODEL:-deepseek-ai/DeepSeek-V3}" ;;
            moonshot)    BASE_URL="${AI_BASE_URL:-https://api.moonshot.cn/v1}"; MODEL="${AI_MODEL:-moonshot-v1-128k}" ;;
            qwen)        BASE_URL="${AI_BASE_URL:-https://dashscope.aliyuncs.com/compatible-mode/v1}"; MODEL="${AI_MODEL:-qwen-max}" ;;
            zhipu)       BASE_URL="${AI_BASE_URL:-https://open.bigmodel.cn/api/paas/v4}"; MODEL="${AI_MODEL:-glm-4-plus}" ;;
            openai)      BASE_URL="${AI_BASE_URL:-https://api.openai.com/v1}"; MODEL="${AI_MODEL:-gpt-4o}" ;;
            anthropic)   BASE_URL="${AI_BASE_URL:-https://api.anthropic.com}"; MODEL="${AI_MODEL:-claude-sonnet-4-20250514}" ;;
            *)           BASE_URL="${AI_BASE_URL:-https://api.deepseek.com/v1}"; MODEL="${AI_MODEL:-deepseek-chat}" ;;
          esac
          # æ ¹æ®æ¨¡å‹è®¾ç½® max_tokens
          case "$MODEL" in
            *reasoner*|*r1*) MAX_TOKENS=16384 ;;
            *) MAX_TOKENS=32768 ;;
          esac
          echo "Using AI: $AI_PROVIDER ($MODEL, max_tokens=$MAX_TOKENS)"

          # ---- å‡†å¤‡ AI è¾“å…¥ï¼šåªå‘é€é SKIP çš„ commitï¼ˆMERGE + OPTIONAL + REVIEWï¼‰ ----
          jq -c '[.[] | select(.action != "SKIP") | {s: .sha[:10], m: .message, a: .action, p: .priority, c: .category}]' \
            /tmp/commits-raw.json > /tmp/ai-candidates.json

          CANDIDATE_COUNT=$(jq 'length' /tmp/ai-candidates.json)
          echo "Sending $CANDIDATE_COUNT candidates to AI for review"

          # ---- è·å– Release Notes ----
          LATEST="${{ needs.check-upstream.outputs.latest_tag }}"
          RELEASE_NOTES=$(gh api "repos/$UPSTREAM_REPO/releases" \
            --jq "[.[] | select(.tag_name == \"$LATEST\") | .body][0]" 2>/dev/null || echo "")

          # ---- æ„å»º Prompt ----
          cat > /tmp/ai-prompt.txt << 'PROMPT_EOF'
          ä½ æ˜¯ openclaw-cnï¼ˆä¸­å›½æœ¬åœ°åŒ– forkï¼‰çš„ä»£ç åˆå¹¶åˆ†æ Agentã€‚
          ä»¥ä¸‹æ˜¯ä»ä¸Šæ¸¸æå–çš„ commitï¼Œå·²ç”±è„šæœ¬åˆæ­¥åˆ†ç±»ã€‚è¯·å®¡æŸ¥å¹¶ä¿®æ­£åˆ†ç±»ã€‚

          ## æˆ‘ä»¬çš„æ¸ é“ä½¿ç”¨æƒ…å†µ
          - âœ… ä½¿ç”¨ä¸­: Telegram, WhatsApp (Web provider), Web UI, TUI, é£ä¹¦ (Feishu)
          - âŒ ä¸ä½¿ç”¨: Line, BlueBubbles, Tlon, Nostr, MS Teams, Twitch, Google Chat,
            iMessage, Mattermost, Nextcloud Talk, Signal, Slack, Discord, Matrix, Zalo,
            Copilot Proxy, Voice Call

          ## åˆ†ç±»è§„åˆ™
          1. **MERGE (P0)**: æ ¸å¿ƒå®‰å…¨ä¿®å¤ï¼ˆgateway/auth/SSRF/XSS/æ³¨å…¥ï¼‰ï¼Œä¸å«æœªä½¿ç”¨æ¸ é“çš„å®‰å…¨ä¿®å¤
          2. **MERGE (P1)**: æ ¸å¿ƒå¼•æ“ bugï¼ˆgateway/agent/session/memory/sandbox/config/cronï¼‰ï¼Œ
             ä½¿ç”¨ä¸­æ¸ é“çš„ bug ä¿®å¤ï¼ŒCJK/Unicode ä¿®å¤ï¼Œæµå¼è¾“å‡ºä¿®å¤
          3. **REVIEW (P2)**: é£ä¹¦ç›¸å…³ï¼ˆéœ€å¯¹æ¯”æœ¬åœ°å®ç°ï¼‰ï¼Œæ–°æ¨¡å‹æ”¯æŒ
          4. **OPTIONAL (P3)**: æ–°åŠŸèƒ½ã€é‡æ„ã€CLI æ”¹å–„ã€UI å¢å¼º
          5. **SKIP (P5)**: ä¸ä½¿ç”¨æ¸ é“çš„ä»»ä½•ä¿®æ”¹ï¼ˆåŒ…æ‹¬å®‰å…¨ä¿®å¤å’Œæµ‹è¯•ï¼‰ï¼Œ
             iOS/Android/macOS åŸç”Ÿåº”ç”¨ï¼ŒCI/CDï¼Œçº¯æ–‡æ¡£ï¼Œçº¯æµ‹è¯•ï¼ˆé™¤éæ¶‰åŠä½¿ç”¨ä¸­æ¸ é“ï¼‰

          ## å…³é”®åˆ¤æ–­
          - "security/line" = Line æ¸ é“å®‰å…¨ä¿®å¤ â†’ **SKIP**ï¼ˆæˆ‘ä»¬ä¸ç”¨ Lineï¼‰
          - "security/nostr" = Nostr å®‰å…¨ä¿®å¤ â†’ **SKIP**
          - "test (security/line)" = Line æ¸ é“æµ‹è¯• â†’ **SKIP**
          - "fix (security/gateway)" = ç½‘å…³æ ¸å¿ƒå®‰å…¨ â†’ **MERGE P0**
          - "fix(discord): ..." â†’ **SKIP**ï¼ˆä¸ç”¨ Discordï¼‰
          - "feat(web): ..." â†’ **OPTIONAL**ï¼ˆWeb UI å¢å¼ºï¼‰
          - "fix(telegram): ..." â†’ **MERGE P1**ï¼ˆä½¿ç”¨ä¸­ï¼‰

          ## è¾“å‡ºæ ¼å¼
          è¾“å‡º JSONï¼Œå¯¹æ¯ä¸ª commit ç»™å‡ºæœ€ç»ˆåˆ†ç±»ï¼ˆè¾“å‡ºå…¨éƒ¨ commitï¼Œä¸è¦çœç•¥ï¼‰ï¼š
          ```json
          [
            {"s": "shaå‰10ä½", "a": "MERGE", "p": "P0", "c": "SECURITY", "r": "æ ¸å¿ƒç½‘å…³å®‰å…¨ä¿®å¤"},
            {"s": "shaå‰10ä½", "a": "SKIP", "p": "P5", "c": "UNUSED-CHANNEL", "r": "Lineæ¸ é“,ä¸ä½¿ç”¨"},
            ...
          ]
          ```
          åªè¾“å‡º JSON æ•°ç»„ï¼Œä¸è¦å…¶ä»–æ–‡å­—ã€‚

          ## å¾…å®¡æŸ¥çš„ commit
          PROMPT_EOF

          cat /tmp/ai-candidates.json >> /tmp/ai-prompt.txt

          if [ -n "$RELEASE_NOTES" ]; then
            echo "" >> /tmp/ai-prompt.txt
            echo "## ä¸Šæ¸¸ Release Notes" >> /tmp/ai-prompt.txt
            echo "$RELEASE_NOTES" >> /tmp/ai-prompt.txt
          fi

          # ---- è°ƒç”¨ AI API ----
          if [ "$AI_PROVIDER" = "anthropic" ]; then
            REQUEST_BODY=$(jq -n --arg model "$MODEL" --argjson max_tokens "$MAX_TOKENS" --rawfile prompt /tmp/ai-prompt.txt '{
              model: $model, max_tokens: $max_tokens,
              messages: [{role: "user", content: $prompt}]
            }')
            curl -s "${BASE_URL}/v1/messages" \
              -H "Content-Type: application/json" \
              -H "x-api-key: $AI_API_KEY" \
              -H "anthropic-version: 2023-06-01" \
              -d "$REQUEST_BODY" > /tmp/ai-response.json
            RESPONSE=$(jq -r '.content[0].text' /tmp/ai-response.json 2>/dev/null)
          else
            # reasoner æ¨¡å‹ä¸æ”¯æŒ temperature å‚æ•°
            if [[ "$MODEL" == *reasoner* ]] || [[ "$MODEL" == *r1* ]]; then
              REQUEST_BODY=$(jq -n --arg model "$MODEL" --argjson max_tokens "$MAX_TOKENS" --rawfile prompt /tmp/ai-prompt.txt '{
                model: $model,
                messages: [{role: "user", content: $prompt}],
                max_tokens: $max_tokens
              }')
            else
              REQUEST_BODY=$(jq -n --arg model "$MODEL" --argjson max_tokens "$MAX_TOKENS" --rawfile prompt /tmp/ai-prompt.txt '{
                model: $model,
                messages: [{role: "user", content: $prompt}],
                max_tokens: $max_tokens, temperature: 0.1
              }')
            fi
            curl -s "${BASE_URL}/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $AI_API_KEY" \
              -d "$REQUEST_BODY" > /tmp/ai-response.json
            RESPONSE=$(jq -r '.choices[0].message.content' /tmp/ai-response.json 2>/dev/null)
          fi

          if [ -z "$RESPONSE" ] || [ "$RESPONSE" = "null" ]; then
            echo "::warning::AI API è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨è„šæœ¬è§„åˆ™åˆ†ç±»"
            cat /tmp/ai-response.json >&2 || true
            echo "ai_used=false" >> "$GITHUB_OUTPUT"
            echo "ai_status=api_failed" >> "$GITHUB_OUTPUT"
            echo "ai_overrides=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "AI response received (${#RESPONSE} chars)"

          # ---- è§£æ AI è¾“å‡º ----
          # ä¿å­˜åŸå§‹å“åº”åˆ°æ–‡ä»¶ï¼ˆé¿å… shell å˜é‡æˆªæ–­å¤§ JSONï¼‰
          printf '%s\n' "$RESPONSE" > /tmp/ai-raw-response.txt

          # é¢„å¤„ç†: æ¸…ç†å¸¸è§ AI è¾“å‡ºæ ¼å¼é—®é¢˜
          # 1. å»é™¤ markdown code fence
          sed -i 's/^```json$//' /tmp/ai-raw-response.txt
          sed -i 's/^```$//' /tmp/ai-raw-response.txt
          # 2. å»é™¤ç©ºè¡Œ
          sed -i '/^[[:space:]]*$/d' /tmp/ai-raw-response.txt
          # 3. å»é™¤ç‹¬ç«‹çš„ [ å’Œ ] è¡Œï¼ˆé…åˆä¸‹é¢çš„ jq -s é‡å»ºæ•°ç»„ï¼‰
          sed -i '/^\[$/d' /tmp/ai-raw-response.txt
          sed -i '/^\]$/d' /tmp/ai-raw-response.txt
          # 4. å»é™¤è¡Œå°¾é€—å·ï¼ˆAI æœ‰æ—¶åŠ é€—å·æœ‰æ—¶ä¸åŠ ï¼Œç»Ÿä¸€å»æ‰åç”¨ jq -s é‡å»ºï¼‰
          sed -i 's/,$//' /tmp/ai-raw-response.txt
          # 5. å†æ¬¡å»é™¤ç©ºè¡Œ
          sed -i '/^[[:space:]]*$/d' /tmp/ai-raw-response.txt

          # å¤„ç† AI è¾“å‡ºè¢«æˆªæ–­çš„æƒ…å†µï¼šåˆ é™¤æœ€åä¸€è¡Œä¸å®Œæ•´çš„ JSON
          TOTAL_LINES=$(wc -l < /tmp/ai-raw-response.txt)
          echo "é¢„å¤„ç†å: $TOTAL_LINES è¡Œ"
          head -3 /tmp/ai-raw-response.txt
          # æ£€æŸ¥æœ€åä¸€è¡Œæ˜¯å¦æ˜¯å®Œæ•´ JSON å¯¹è±¡
          LAST_LINE=$(tail -1 /tmp/ai-raw-response.txt)
          if ! printf '%s' "$LAST_LINE" | jq '.' >/dev/null 2>&1; then
            echo "âš ï¸ æœ€åä¸€è¡Œä¸å®Œæ•´ï¼ˆAI è¾“å‡ºè¢«æˆªæ–­ï¼‰ï¼Œå·²åˆ é™¤: ${LAST_LINE:0:60}..."
            sed -i '$ d' /tmp/ai-raw-response.txt
            TOTAL_LINES=$(wc -l < /tmp/ai-raw-response.txt)
            echo "æˆªæ–­åå‰©ä½™: $TOTAL_LINES è¡Œ"
          fi

          # ç°åœ¨æ–‡ä»¶æ˜¯çº¯ JSONLï¼ˆæ¯è¡Œä¸€ä¸ª JSON å¯¹è±¡ï¼Œæ—  [ ] æ— é€—å·ï¼‰
          # ç”¨ jq -s æŠŠ JSONL åˆå¹¶ä¸ºæ•°ç»„
          AI_DECISIONS=""
          if AI_DECISIONS=$(jq -sc '.' /tmp/ai-raw-response.txt 2>/tmp/jq-err.txt); then
            # éªŒè¯æ˜¯éç©ºæ•°ç»„
            AI_LEN=$(printf '%s\n' "$AI_DECISIONS" | jq 'if type == "array" then length else 0 end' 2>/dev/null || echo "0")
            if [ "$AI_LEN" -eq 0 ]; then
              echo "jq -s è¿”å›ç©ºæ•°ç»„"
              AI_DECISIONS=""
            else
              echo "âœ… è§£ææˆåŠŸ: $AI_LEN æ¡ AI å†³ç­–"
            fi
          else
            echo "jq -s å¤±è´¥: $(cat /tmp/jq-err.txt)"
            AI_DECISIONS=""
          fi

          if [ -z "$AI_DECISIONS" ] || [ "$AI_DECISIONS" = "null" ]; then
            echo "::warning::AI è¾“å‡ºè§£æå¤±è´¥ï¼Œä½¿ç”¨è„šæœ¬è§„åˆ™åˆ†ç±»"
            echo "--- åŸå§‹å“åº”å‰ 30 è¡Œ ---"
            head -30 /tmp/ai-raw-response.txt
            echo "--- jq é”™è¯¯ ---"
            cat /tmp/jq-err.txt 2>/dev/null || true
            echo "ai_used=false" >> "$GITHUB_OUTPUT"
            echo "ai_status=parse_failed" >> "$GITHUB_OUTPUT"
            echo "ai_overrides=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          AI_COUNT=$(printf '%s\n' "$AI_DECISIONS" | jq 'length')
          echo "AI returned $AI_COUNT decisions"

          # å°† AI å†³ç­–ä¿å­˜ä¸ºæ–‡ä»¶ï¼Œç”¨ jq ä¸€æ¬¡æ€§åˆå¹¶
          printf '%s\n' "$AI_DECISIONS" > /tmp/ai-overrides.json

          # ç”¨ jq åˆå¹¶ AI å†³ç­–åˆ° commits.json
          # æ³¨æ„: AI åªå®¡æŸ¥äº†é SKIP çš„ commitï¼ŒSKIP çš„ä¿æŒä¸å˜
          jq --slurpfile overrides /tmp/ai-overrides.json '
            ($overrides[0] | map(select(.s != null) | {key: .s, value: .}) | from_entries) as $idx |
            [.[] |
              (.sha[:10]) as $prefix |
              if $idx[$prefix] then
                .action = ($idx[$prefix].a // .action) |
                .priority = ($idx[$prefix].p // .priority) |
                .category = ($idx[$prefix].c // .category) |
                if $idx[$prefix].r then .ai_note = $idx[$prefix].r else . end
              else . end
            ]' /tmp/commits.json > /tmp/commits-merged.json || {
              echo "::warning::jq åˆå¹¶å¤±è´¥ï¼Œä½¿ç”¨è„šæœ¬è§„åˆ™åˆ†ç±»"
              jq '.' /tmp/ai-overrides.json | head -5 >&2 || true
              echo "ai_used=false" >> "$GITHUB_OUTPUT"
              echo "ai_status=merge_failed" >> "$GITHUB_OUTPUT"
              echo "ai_overrides=0" >> "$GITHUB_OUTPUT"
              exit 0
            }

          mv /tmp/commits-merged.json /tmp/commits.json

          # æ‰“å°è¢«ä¿®æ”¹çš„æ¡ç›®
          jq -r '.[] | select(.ai_note) | "  ğŸ”„ \(.sha[:10]): \(.action)/\(.priority) â€” \(.ai_note)"' /tmp/commits.json || true

          # ç»Ÿè®¡è¢« AI ä¿®æ”¹çš„æ¡ç›®æ•°ï¼ˆæ¯”è¾ƒ action å­—æ®µå˜åŒ–ï¼‰
          OVERRIDE_COUNT=0
          OVERRIDE_COUNT=$(diff \
            <(jq -c '[.[] | {s: .sha[:10], a: .action}]' /tmp/commits-raw.json) \
            <(jq -c '[.[] | {s: .sha[:10], a: .action}]' /tmp/commits.json) \
            | grep -c '^[<>]' || true)
          OVERRIDE_COUNT=$((OVERRIDE_COUNT / 2))

          echo "ai_used=true" >> "$GITHUB_OUTPUT"
          echo "ai_status=success" >> "$GITHUB_OUTPUT"
          echo "ai_overrides=$OVERRIDE_COUNT" >> "$GITHUB_OUTPUT"
          echo "âœ… AI åˆ†æå®Œæˆï¼Œä¿®æ­£äº† $OVERRIDE_COUNT é¡¹åˆ†ç±»"

      - name: Upload refined commits
        uses: actions/upload-artifact@v4
        with:
          name: refined-commits
          path: /tmp/commits.json
          retention-days: 7

      - name: Calculate statistics
        id: stats
        run: |
          f() { jq "$1" /tmp/commits.json; }
          echo "total=$(f 'length')" >> "$GITHUB_OUTPUT"
          echo "merge_count=$(f '[.[] | select(.action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "p0=$(f '[.[] | select(.priority == "P0" and .action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "p1=$(f '[.[] | select(.priority == "P1" and .action == "MERGE")] | length')" >> "$GITHUB_OUTPUT"
          echo "review=$(f '[.[] | select(.action == "REVIEW")] | length')" >> "$GITHUB_OUTPUT"
          echo "skip=$(f '[.[] | select(.action == "SKIP")] | length')" >> "$GITHUB_OUTPUT"
          echo "optional=$(f '[.[] | select(.action == "OPTIONAL")] | length')" >> "$GITHUB_OUTPUT"

      - name: Create issue with embedded checklist
        id: issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREV="${{ needs.check-upstream.outputs.prev_tag }}"
          LATEST="${{ needs.check-upstream.outputs.latest_tag }}"
          TAGS="${{ needs.check-upstream.outputs.release_tags }}"
          AI_USED="${{ steps.ai.outputs.ai_used }}"
          AI_STATUS="${{ steps.ai.outputs.ai_status }}"
          AI_OVERRIDES="${{ steps.ai.outputs.ai_overrides }}"

          # å»é‡æ£€æŸ¥
          EXISTING=$(gh issue list -R "$GITHUB_REPOSITORY" --label "upstream" --state open \
            --search "$LATEST in:title" --json number --jq '.[0].number // empty')
          if [ -n "$EXISTING" ]; then
            echo "number=$EXISTING" >> "$GITHUB_OUTPUT"
            echo "Issue #$EXISTING already exists, skipping"
            exit 0
          fi

          P0="${{ steps.stats.outputs.p0 }}"
          P1="${{ steps.stats.outputs.p1 }}"
          MERGE="${{ steps.stats.outputs.merge_count }}"
          REVIEW="${{ steps.stats.outputs.review }}"
          SKIP="${{ steps.stats.outputs.skip }}"
          OPTIONAL="${{ steps.stats.outputs.optional }}"
          TOTAL="${{ steps.stats.outputs.total }}"

          # æ„å»º Issue å†…å®¹
          {
            echo "## ä¸Šæ¸¸æ–° Release: $TAGS"
            echo ""
            echo "**èŒƒå›´**: \`$PREV\` â†’ \`$LATEST\` | å…± **$TOTAL** ä¸ª commit"
            echo ""
            if [ "$AI_USED" = "true" ]; then
              echo "> ğŸ§  **AI å·²å®¡æŸ¥åˆ†ç±»**ï¼ˆä¿®æ­£äº† **$AI_OVERRIDES** é¡¹ï¼‰"
            elif [ "$AI_STATUS" = "not_configured" ]; then
              echo "> âš™ï¸ ä½¿ç”¨è§„åˆ™å¼•æ“åˆ†ç±»ï¼ˆæœªé…ç½® AI_API_KEYï¼‰"
            elif [ "$AI_STATUS" = "api_failed" ]; then
              echo "> âš ï¸ AI API è°ƒç”¨å¤±è´¥ï¼Œå·²å›é€€åˆ°è§„åˆ™å¼•æ“åˆ†ç±»"
            elif [ "$AI_STATUS" = "parse_failed" ]; then
              echo "> âš ï¸ AI è¿”å›ç»“æœè§£æå¤±è´¥ï¼Œå·²å›é€€åˆ°è§„åˆ™å¼•æ“åˆ†ç±»"
            elif [ "$AI_STATUS" = "merge_failed" ]; then
              echo "> âš ï¸ AI å†³ç­–åˆå¹¶å¤±è´¥ï¼Œå·²å›é€€åˆ°è§„åˆ™å¼•æ“åˆ†ç±»"
            else
              echo "> âš™ï¸ ä½¿ç”¨è§„åˆ™å¼•æ“åˆ†ç±»"
            fi
            echo ""
            echo "### ğŸ“Š åˆ†ç±»æ‘˜è¦"
            echo ""
            echo "| ç±»åˆ« | æ•°é‡ | å¤„ç†æ–¹å¼ |"
            echo "|------|------|----------|"
            echo "| ğŸ”´ P0 å®‰å…¨ä¿®å¤ | **$P0** | è‡ªåŠ¨ cherry-pick |"
            echo "| ğŸŸ  P1 å…³é”®ä¿®å¤ | **$P1** | è‡ªåŠ¨ cherry-pick |"
            echo "| ğŸ‘ éœ€äººå·¥å®¡æŸ¥ | **$REVIEW** | æ‰‹åŠ¨å¤„ç† |"
            echo "| ğŸ”µ å¯é€‰ | **$OPTIONAL** | æŒ‰éœ€ |"
            echo "| âšª å·²è·³è¿‡ | **$SKIP** | ä¸ä½¿ç”¨çš„æ¸ é“/CI/docs |"
            echo ""
            echo "---"
            echo ""
            echo "### âœ… è‡ªåŠ¨åˆå¹¶æ¸…å• (P0+P1)"
            echo ""
            if [ "$MERGE" -gt 0 ]; then
              echo "| çŠ¶æ€ | ä¼˜å…ˆçº§ | Commit | æè¿° | ç±»åˆ« | é£é™© |"
              echo "|------|--------|--------|------|------|------|"
              jq -r '.[] | select(.action == "MERGE") |
                "| â³ | \(.priority) | `\(.sha[:10])` | \(.message | gsub("[|]"; "/")) | \(.category) | \(.conflict_risk) |"' \
                /tmp/commits.json
            else
              echo "_æ— éœ€åˆå¹¶çš„ commit_"
            fi
            echo ""
            if [ "$AI_USED" = "true" ] && [ "$AI_OVERRIDES" -gt 0 ]; then
              echo "<details>"
              echo "<summary>ğŸ§  AI ä¿®æ­£è®°å½• ($AI_OVERRIDES é¡¹)</summary>"
              echo ""
              echo "| Commit | æè¿° | AI å¤‡æ³¨ |"
              echo "|--------|------|---------|"
              jq -r '.[] | select(.ai_note) |
                "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/") | .[0:60]) | \(.ai_note) |"' \
                /tmp/commits.json
              echo ""
              echo "</details>"
              echo ""
            fi
            echo "> ğŸ¤– è‡ªåŠ¨ cherry-pick PR åˆ›å»ºåå°†åœ¨ä¸‹æ–¹è¯„è®ºæ›´æ–°ç»“æœ"
            echo ""
            if [ "$REVIEW" -gt 0 ]; then
              echo "### ğŸ‘ éœ€äººå·¥å®¡æŸ¥"
              echo ""
              echo "| Commit | æè¿° | ç±»åˆ« | å¤‡æ³¨ |"
              echo "|--------|------|------|------|"
              jq -r '.[] | select(.action == "REVIEW") |
                "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/")) | \(.category) | éœ€å¯¹æ¯”æœ¬åœ°å®ç° |"' \
                /tmp/commits.json
              echo ""
            fi
            if [ "$OPTIONAL" -gt 0 ]; then
              echo "<details>"
              echo "<summary>ğŸ”µ å¯é€‰åˆå¹¶ ($OPTIONAL ä¸ª)</summary>"
              echo ""
              echo "| Commit | æè¿° | ç±»åˆ« |"
              echo "|--------|------|------|"
              jq -r '[.[] | select(.action == "OPTIONAL")] | limit(50; .[]) |
                "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/") | .[0:80]) | \(.category) |"' \
                /tmp/commits.json
              echo ""
              echo "</details>"
              echo ""
            fi
            echo "<details>"
            echo "<summary>âšª å·²è·³è¿‡ ($SKIP ä¸ª)</summary>"
            echo ""
            echo "| Commit | æè¿° | ç±»åˆ« |"
            echo "|--------|------|------|"
            jq -r '[.[] | select(.action == "SKIP")] | limit(50; .[]) |
              "| `\(.sha[:10])` | \(.message | gsub("[|]"; "/") | .[0:60]) | \(.category) |"' \
              /tmp/commits.json
            SKIP_INT=$(jq '[.[] | select(.action == "SKIP")] | length' /tmp/commits.json)
            if [ "$SKIP_INT" -gt 50 ]; then
              echo ""
              echo "_... åŠå…¶ä»– $((SKIP_INT - 50)) ä¸ª commit_"
            fi
            echo ""
            echo "</details>"
            echo ""
            echo "---"
            echo ""
            echo "### ğŸ”§ æ‰‹åŠ¨è¡¥å……æ“ä½œ"
            echo ""
            echo '```bash'
            echo "# å®¡æŸ¥é¡¹"
            echo "./scripts/upstream-cherry-pick.sh --priority P2 --dry-run"
            echo "# å¯é€‰é¡¹"
            echo "./scripts/upstream-cherry-pick.sh --priority P0,P1,P2,P3 --dry-run"
            echo '```'
            echo ""
            echo "æˆ–: **Actions â†’ Upstream Cherry-Pick** â†’ é€‰æ‹©ä¼˜å…ˆçº§"
            echo ""
            echo "### ğŸ›¡ Cherry-pick ä¿æŠ¤æœºåˆ¶"
            echo "è‡ªåŠ¨æ¢å¤æœ¬åœ°æ–‡ä»¶: \`docs/\` \`extensions/feishu/\` \`package.json\` \`.github/workflows/\` \`CHANGELOG.md\` \`README.md\`"
          } > /tmp/issue-body.md

          gh label create upstream --description "ä¸Šæ¸¸å˜æ›´è¿½è¸ª" --color "0075ca" --force -R "$GITHUB_REPOSITORY" 2>&1 || true

          ISSUE_URL=$(gh issue create -R "$GITHUB_REPOSITORY" \
            --title "ä¸Šæ¸¸æ›´æ–°: $TAGS â€” ${P0} P0 + ${P1} P1 å¾…åˆå¹¶" \
            --body-file /tmp/issue-body.md \
            --label "upstream" 2>&1) || \
          ISSUE_URL=$(gh issue create -R "$GITHUB_REPOSITORY" \
            --title "ä¸Šæ¸¸æ›´æ–°: $TAGS â€” ${P0} P0 + ${P1} P1 å¾…åˆå¹¶" \
            --body-file /tmp/issue-body.md)

          NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          echo "number=$NUMBER" >> "$GITHUB_OUTPUT"
          echo "Created issue #$NUMBER"

      - name: Update baseline tag
        if: ${{ !inputs.dry_run }}
        run: |
          git config user.name "upstream-monitor[bot]"
          git config user.email "bot@openclaw-cn.dev"

          LATEST="${{ needs.check-upstream.outputs.latest_tag }}"
          PREV="${{ needs.check-upstream.outputs.prev_tag }}"

          echo "$LATEST" > "$LAST_TAG_FILE"

          COMMIT_MAP_DIR=".github/upstream-commits"
          mkdir -p "$COMMIT_MAP_DIR"
          cp /tmp/commits.json "$COMMIT_MAP_DIR/${PREV}..${LATEST}.json"

          git add "$LAST_TAG_FILE" "$COMMIT_MAP_DIR/"
          if ! git diff --cached --quiet; then
            git commit -m "chore: track upstream $LATEST"
            git push
          fi

  # ================================================================
  # Job 3: è‡ªåŠ¨ cherry-pick P0+P1 å¹¶åˆ›å»º PR
  # ================================================================
  auto-cherry-pick:
    needs: [check-upstream, extract-and-notify]
    if: ${{ !inputs.dry_run && fromJSON(needs.extract-and-notify.outputs.merge_count) > 0 }}
    uses: ./.github/workflows/upstream-cherry-pick.yml
    with:
      from_tag: ${{ needs.check-upstream.outputs.prev_tag }}
      to_tag: ${{ needs.check-upstream.outputs.latest_tag }}
      priority: 'P0,P1'
      dry_run: false
      skip_build: true
      issue_number: ${{ needs.extract-and-notify.outputs.issue_number }}
    secrets: inherit
